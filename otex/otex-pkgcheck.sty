\ProvidesExplPackage {otex/otex-pkgcheck} {2026-01-16} {1.1} {Orion's Smart Package Checker}

% ==============================================================================
% otex-pkgcheck.sty - Orion's 智能宏包管理器
% ==============================================================================
% 该模块是 otex 系统中处理宏包加载冲突与延迟配置的核心组件。其设计思想如下：
% 1. 延迟配置 (Lazy Setup)：利用 LaTeX 2020 后引入的 Hook 系统，确保配置代码在宏包加载后立即执行。
% 2. 多重冲突检测：
%    - 基于 \IfPackageLoadedTF 的标准检测：识别已通过 \RequirePackage 加载的包。
%    - 基于“守护符号 (Guard Symbol)”的深度探测：识别未标准加载但已定义关键命令的包（如在 .cls 中定义的）。
% 3. 精准通知：区分“otex 自加载”与“用户预加载”，避免对 otex 内部依赖产生多余警告。
% ==============================================================================


% 现代 Hook 系统支持：利用 LaTeX 2020 年 10 月版引入的新特性进行宏包管理
% 我们假设内核已提供 \AddToHook 和 \IfPackageLoadedTF 命令。

% 定义一系列消息，用于向用户报告宏包冲突、预加载状态或跳过操作。
\msg_new:nnn { otex } { pkg-conflict } { Package~'#1'~conflict:~symbol~'#2'~defined.~Skipping~load. }
\msg_new:nnn { otex } { pkg-loaded } { Package~'#1'~already~loaded.~Skipping~otex~default~config. }
\msg_new:nnn { otex } { pkg-skip } { Skipping~'#1':~#2. }

% 全局宏包追踪序列：
% 记录所有由 otex 系统主动调用的 \RequirePackage 行为。
% 这是一个关键的数据结构，用于在 \otex_safe_require:nnnn 中区分是否应该报出“宏包已存在”的警告。
\seq_new:N \g_otex_loaded_packages_seq

% 自动追踪 Hook：
% 每当一个宏包加载完成（package/after 钩子触发），我们将当前宏包名 (\g_file_curr_name_str) 存入追踪序列。
% 这保证了序列始终包含当前编译周期中所有已加载的宏包名称。
\AddToHook { package/after }
{
  \seq_gput_right:Nx \g_otex_loaded_packages_seq { \g_file_curr_name_str }
}

% ------------------------------------------------------------------------------
% 核心功能接口 (Primitives)
% ------------------------------------------------------------------------------

% 宏包延迟配置机制：
% #1: 宏包名称（不含 .sty 扩展名）
% #2: 配置代码块（当宏包加载时执行）
% 
% 设计逻辑：
% 使用 LaTeX 核心 Hook 'package/#1/after'。即使该宏包尚未加载，配置也会被“排队”。
% 这种方式比常规的 \AtBeginDocument 更早（紧随包加载），且解决了加载顺序的强依赖问题。
\cs_new_protected:Npn \otex_setup_package:nn #1#2
{
  \AddToHook { package/#1/after } { #2 }
}


% 智能安全加载器 (otex_safe_require)
% 这是 otex 解决宏包冲突的核心函数。它采用三层逻辑来确保系统的鲁棒性：
% 
% 参数说明：
% #1: 待加载的宏包名称 (e.g., hyperref)
% #2: 传递给宏包的选项列表 (clist, e.g., colorlinks=true)
% #3: 守护符号 (token, e.g., \hypersetup)。如果该符号已定义，则视为冲突。
% #4: otex 的默认配置代码块。
% 
% 逻辑流程：
% 1. 检查宏包是否已加载：
%    - 若已加载，我们注册 otex 的配置 (#4)，但置位 \l_otex_pkg_preloaded_bool 为真。
%    - 这样 otex 的配置代码可以通过检查这个布尔变量来决定是否跳过某些“侵略性”设置（如强制修改页边距）。
%    - 同时，如果该宏包不是由 otex 自身加载的，则发出警告提醒用户。
% 2. 检查守护符号：
%    - 有些模板可能通过非标准方式（如直接输入文件或在 class 中重定义）提供了包的功能。
%    - 如果参数 #3 (守护符号) 存在，我们认为发生了潜在命名冲突，放弃加载。
% 3. 环境干净：
%    - 执行常规的 \RequirePackage 并注册配置。
\cs_new_protected:Npn \otex_safe_require:nnnn #1#2#3#4
{
  % 步骤 1：探测宏包名是否在 LaTeX 的 loaded 列表中
  \IfPackageLoadedTF { #1 }
  {
    % 宏包已存在。注册配置，并标记为“预加载”模式。
    \otex_setup_package:nn { #1 }
    {
      \bool_set_true:N \l_otex_pkg_preloaded_bool
      #4
    }

    % 发出警告，前提是：这包不是 otex 自己刚才加载的。
    % 这样可以过滤掉内部模块间相互依赖产生的 log 杂音。
    \seq_if_in:NnF \g_otex_loaded_packages_seq { #1 }
    {
      \msg_warning:nnn { otex } { pkg-loaded } { #1 }
      % 将其加入序列，避免针对同一宏包产生多次重复警告（如多次 \RequirePackage{otex} 时）
      \seq_gput_right:Nn \g_otex_loaded_packages_seq { #1 }
    }
  }
  {
    % 步骤 2：守护符号冲突检查
    \bool_lazy_any:nTF
    {
      { \tl_if_empty_p:n { #3 } } % 用户未定义守护符号，跳过此步
      { 
        % 增加防御性编程：仅当 #3 为单个 token 时才调用 \cs_if_exist_p:N
        % 否则如果 #3 是 "{foo}" 或者 "invalid string"，会导致底层报错
        \bool_lazy_and_p:nn 
          { \tl_if_single_token_p:n { #3 } }
          { \cs_if_exist_p:N #3 }
      }     % 守护符号已存在，触发冲突
    }
    {
      \tl_if_empty:nTF { #3 }
      {
        % 符号为空，说明没有冲突风险，允许加载
        \otex_setup_package:nn { #1 } { \bool_set_false:N \l_otex_pkg_preloaded_bool #4 }
        \tl_if_empty:nTF { #2 }
        { \RequirePackage { #1 } }
        { \RequirePackage [ #2 ] { #1 } }
      }
      {
        % 发现冲突符号！
        \msg_warning:nnnn { otex } { pkg-conflict } { #1 } { #3 }
      }
    }
    {
      % 步骤 3：正式加载。设置 preloaded 标志为假，以便全额应用 otex 默认配置。
      \otex_setup_package:nn { #1 } { \bool_set_false:N \l_otex_pkg_preloaded_bool #4 }
      \tl_if_empty:nTF { #2 }
      { \RequirePackage { #1 } }
      { \RequirePackage [ #2 ] { #1 } }
    }
  }
}


% 定义布尔标志：用于区分是否在 otex 之前“预加载”与“非预加载”状态
% 该标志在 \otex_safe_require:nnnn 中用于判断是否应该报出“宏包已存在”的警告。
\bool_new:N \l_otex_pkg_preloaded_bool

% 定义辅助宏：提供容错性的命令/环境定义
% 仅在目标命令或环境未被占用时才执行定义动作。
\cs_new_protected:Npn \otex_provide_command:Nnn #1#2#3
{
  \cs_if_exist:NF #1 { \DeclareDocumentCommand #1 { #2 } { #3 } }
}

\cs_new_protected:Npn \otex_provide_env:nnnn #1#2#3#4
{
  \cs_if_exist:cF { #1 } { \NewDocumentEnvironment { #1 } { #2 } { #3 } { #4 } }
}

\endinput
