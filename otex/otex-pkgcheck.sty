\ProvidesExplPackage {otex/otex-pkgcheck} {2026-01-16} {1.1} {Orion's Smart Package Checker}
% 引入冲突知识库模块
\RequirePackage{otex/otex-pkgconflict}

% ==============================================================================
% otex-pkgcheck.sty - Orion's 智能宏包管理器
% ==============================================================================
% 该模块是 otex 系统中处理宏包加载冲突与延迟配置的核心组件。其设计思想如下：
% 1. 延迟配置 (Lazy Setup)：利用 LaTeX 2020 后引入的 Hook 系统，确保配置代码在宏包加载后立即执行。
% 2. 多重冲突检测：
%    - 基于 \IfPackageLoadedTF 的标准检测：识别已通过 \RequirePackage 加载的包。
%    - 基于“守护符号 (Guard Symbol)”的深度探测：识别未标准加载但已定义关键命令的包（如在 .cls 中定义的）。
% 3. 精准通知：区分“otex 自加载”与“用户预加载”，避免对 otex 内部依赖产生多余警告。
% ==============================================================================

% 现代 Hook 系统支持：利用 LaTeX 2020 年 10 月版引入的新特性进行宏包管理
% 我们假设内核已提供 \AddToHook 和 \IfPackageLoadedTF 命令。

% 定义一系列消息，用于向用户报告宏包冲突、预加载状态或跳过操作。
\msg_new:nnn { otex } { pkg-conflict-symbol } { Package~'#1'~conflict:~symbol~'#2'~defined.~Skipping~load. }
\msg_new:nnn { otex } { pkg-loaded } { Package~'#1'~already~loaded.~Skipping~otex~default~config. }
\msg_new:nnn { otex } { pkg-skip } { Skipping~'#1':~#2. }
\msg_new:nnn { otex } { pkg-conflict-group } { Conflict~detected:~Package~'#1'~conflicts~with~loaded~package~'#2'.~Skipping. }

% 全局宏包追踪集合（Property List）：
% 记录所有由 otex 系统主动或被动调用的 \RequirePackage 行为。
% 使用 prop 结构以实现 O(1) 的快速查找，替代原本的线性序列扫描。
\prop_new:N \g_otex_loaded_packages_prop

% 自动追踪 Hook：
% 每当一个宏包加载完成（package/after 钩子触发），我们将当前宏包名存入追踪集合。
% 我们使用 \str_set:Nx 强制转换为字符串，消除 category code 差异带来的匹配失败。
\AddToHook { package/after }
{
  \str_set:Nx \l_otex_hook_curr_pkg_str { \@currname }
  \prop_gput:NVn \g_otex_loaded_packages_prop \l_otex_hook_curr_pkg_str { }
}

% ------------------------------------------------------------------------------
% 核心功能接口 (Primitives)
% ------------------------------------------------------------------------------

% 宏包延迟配置机制：
% #1: 宏包名称（不含 .sty 扩展名）
% #2: 配置代码块（当宏包加载时执行）
%
% 设计逻辑：
% 使用 LaTeX 核心 Hook 'package/#1/after'。即使该宏包尚未加载，配置也会被“排队”。
% 这种方式比常规的 \AtBeginDocument 更早（紧随包加载），且解决了加载顺序的强依赖问题。
\cs_new_protected:Npn \otex_setup_package:nn #1#2
{
  \AddToHook { package/#1/after } { #2 }
}

% 辅助函数：简化版守卫符号检测
% 检查 token #1 是否已定义
\prg_new_conditional:Npnn \otex_symbol_defined:n #1 { TF }
{
  \tl_if_empty:nTF { #1 }
  { \prg_return_false: }
  { \cs_if_exist:NTF #1 { \prg_return_true: } { \prg_return_false: } }
}

% 定义内部变量用于存储冲突列表
\clist_new:N \l_otex_conflicts_clist

% 智能安全加载器 (otex_safe_require)
% 增强版：结合“已知冲突库”与“守卫符号”双重检测
%
% 参数说明：
% #1: 待加载的宏包名称 (e.g., hyperref)
% #2: 传递给宏包的选项列表 (clist, e.g., colorlinks=true)
% #3: 守护符号 (token, e.g., \hypersetup)。仅作为冲突检测的最后防线。
% #4: otex 的默认配置代码块。
%
% 逻辑流程：
% 1. 检查宏包是否已加载 (\IfPackageLoadedTF)。
% 2. 检查已知冲突 (Conflict Edge Registry)。
% 3. 检查守护符号 (Guard Symbol Check)。
% 4. 均无冲突则加载。
\cs_new_protected:Npn \otex_safe_require:nnnn #1#2#3#4
{
  % 步骤 1：直接探测宏包名是否不在加载列表中
  \IfPackageLoadedTF { #1 }
  {
    % 宏包已存在。注册配置，并标记为“预加载”模式。
    \otex_setup_package:nn { #1 }
    {
      \bool_set_true:N \l_otex_pkg_preloaded_bool
      #4
    }

    % 检查是否由 otex 系统内部加载：
    % 直接查表 (O(1)) 判断 package 是否在追踪集合中
    % 为了确保匹配准确性，先将输入包名转换为 string
    \str_set:Nn \l_otex_target_pkg_str { #1 }
    \prop_if_in:NVTF \g_otex_loaded_packages_prop \l_otex_target_pkg_str
    {
      \bool_set_true:N \l_otex_pkg_internal_bool
    }
    {
      \bool_set_false:N \l_otex_pkg_internal_bool
    }

    \bool_if:NF \l_otex_pkg_internal_bool
    {
      \msg_warning:nnn { otex } { pkg-loaded } { #1 }
      % 标记为已警告，存入集合防止二次爆发
      \prop_gput:NVn \g_otex_loaded_packages_prop \l_otex_target_pkg_str { }
    }
  }
  {
    % 宏包未加载。进入冲突检测流程。
    \bool_set_false:N \l_otex_conflict_found_bool

    % 步骤 2：基于知识库的冲突检测
    \otex_get_conflicts:nN { #1 } \l_otex_conflicts_clist
    \clist_map_inline:Nn \l_otex_conflicts_clist
    {
      \IfPackageLoadedTF { ##1 }
      {
        % 发现互斥包已加载
        \msg_warning:nnnn { otex } { pkg-conflict-group } { #1 } { ##1 }
        \bool_set_true:N \l_otex_conflict_found_bool
        \clist_map_break:
      }
    }

    \bool_if:NTF \l_otex_conflict_found_bool
    {
      % 发生主要冲突，跳过加载
    }
    {
      % 步骤 3：守护符号冲突检测 (Fallback)
      \otex_symbol_defined:nTF { #3 }
      {
        % 符号已定义，说明有隐式冲突
        \msg_warning:nnnn { otex } { pkg-conflict-symbol } { #1 } { #3 }
      }
      {
        % 步骤 4：环境干净，正式加载
        \otex_setup_package:nn { #1 }
        {
          \bool_set_false:N \l_otex_pkg_preloaded_bool
          #4
        }
        \str_set:Nn \l_otex_target_pkg_str { #1 }
        \prop_gput:NVn \g_otex_loaded_packages_prop \l_otex_target_pkg_str { }
        \tl_if_empty:nTF { #2 }
        { \RequirePackage { #1 } }
        { \RequirePackage [ #2 ] { #1 } }
      }
    }
  }
}

% 定义布尔标志：用于区分是否在 otex 之前“预加载”与“非预加载”状态
% 该标志在 \otex_safe_require:nnnn 中用于判断是否应该报出“宏包已存在”的警告。
\bool_new:N \l_otex_pkg_preloaded_bool
\bool_new:N \l_otex_conflict_found_bool

% 定义辅助宏：提供容错性的命令/环境定义
% 仅在目标命令或环境未被占用时才执行定义动作。
\cs_new_protected:Npn \otex_provide_command:Nnn #1#2#3
{
  \cs_if_exist:NF #1 { \DeclareDocumentCommand #1 { #2 } { #3 } }
}

\cs_new_protected:Npn \otex_provide_env:nnnn #1#2#3#4
{
  \cs_if_exist:cF { #1 } { \NewDocumentEnvironment { #1 } { #2 } { #3 } { #4 } }
}

\endinput
